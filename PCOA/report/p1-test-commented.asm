ori $3,$0,0x93      # $3写入0x0000_0093
ori $6,$0,0xae      # $6写入0x0000_00ae
addu $8,$3,$6       # 计算$3(0x93)和$6(0xae)的和，存入$8(0x141)
subu $9,$3,$6       # 计算$3(0x93)和$6(0xae)的差，存入$9(-0x1b)
                    #   $9(-0x1b)实际存储使用补码表示，为0xffff_ffe5
addu $0,$9,$10      # 计算$9(0x141)和$10(-0x1b)的和(0x126)，存入$0
                    #   由于$0寄存器禁止写入，$0会保持0x0000_0000
sw $9,16($0)        # 将$9(0x141)的值存入地址为0x10的内存
lw $10,16($0)       # 将地址为0x10的内存数据(0x141)存入$10
l3:                 # 跳转标志l3
beq $9,$10,l1       # 若$9和$10相等，跳转到l1，否则执行下一条指令
                    #   第一次运行：$9(0x141)==$10(0x141)，跳转到l1
                    #   第二次运行：$9(0x45670000)!=$10(0x141)，执行下一条指令
lui $11,0xcdcd      # $11写入0xcdcd_0000
j end               # 跳转到end
l1:                 # 跳转标志l1
ori $11,$0,0xefef   # $11写入0x0000_efef
lui $9,0x4567       # $9写入0x4567_0000
j l3                # 跳转到l3
end:                # 跳转标志end
